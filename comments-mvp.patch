*** a/prisma/schema.prisma
--- b/prisma/schema.prisma
@@
 model Vote {
   id        String   @id @default(cuid())
   userId    String
   optionId  String
   timestamp DateTime @default(now())
 
   user   User   @relation(fields: [userId], references: [id])
   option Option @relation(fields: [optionId], references: [id])
+
+  @@index([userId, timestamp])
+  @@index([optionId, timestamp])
 }
 
 model Option {
   id     String @id @default(cuid())
   text   String
   pollId String
   poll   Poll   @relation(fields: [pollId], references: [id])
   votes  Vote[]
+
+  @@index([pollId])
 }
 
 model Poll {
   id        String    @id @default(cuid())
   question  String
   startDate DateTime
   endDate   DateTime
   closedAt  DateTime? // When poll is closed & results are revealed
   options   Option[]
+
+  @@index([startDate])
+  @@index([endDate])
 }
 
 model Badge {
   id          Int         @id @default(autoincrement())
   name        String      @unique
   icon        String // Emoji or path to image
   description String
   unlockHint  String // How to earn it
   users       UserBadge[]
 }
 
 model UserBadge {
   id       Int      @id @default(autoincrement())
   user     User     @relation(fields: [userId], references: [id])
   userId   String
   badge    Badge    @relation(fields: [badgeId], references: [id])
   badgeId  Int
   earnedAt DateTime @default(now())
 
   @@unique([userId, badgeId])
+  @@index([userId, earnedAt])
 }
+
+// ─────────── Comments / Threads MVP (schema slice) ───────────
+
+enum ThreadType {
+  POLL      // per-poll discussion (link via pollId)
+  TOPIC     // user-created subject
+  FEEDBACK  // app feedback
+}
+
+model Thread {
+  id           String     @id @default(cuid())
+  type         ThreadType
+  title        String
+  pollId       String?
+  createdById  String
+  createdAt    DateTime   @default(now())
+  updatedAt    DateTime   @updatedAt
+
+  // denormalized for sorting
+  commentCount Int        @default(0)
+  likeCount    Int        @default(0)
+
+  createdBy    User       @relation(fields: [createdById], references: [id])
+  poll         Poll?      @relation(fields: [pollId], references: [id])
+  comments     Comment[]
+
+  @@index([type, createdAt])
+  @@index([pollId])
+}
+
+model Comment {
+  id          String    @id @default(cuid())
+  threadId    String
+  parentId    String?
+  userId      String
+  content     String
+  isAnonymous Boolean   @default(false)
+  createdAt   DateTime  @default(now())
+  updatedAt   DateTime  @updatedAt
+  deletedAt   DateTime?
+
+  // denormalized for sorting
+  replyCount  Int       @default(0)
+  likeCount   Int       @default(0)
+
+  thread      Thread    @relation(fields: [threadId], references: [id])
+  parent      Comment?  @relation("CommentChildren", fields: [parentId], references: [id])
+  children    Comment[] @relation("CommentChildren")
+  user        User      @relation(fields: [userId], references: [id])
+  reactions   Reaction[]
+
+  @@index([threadId, createdAt])
+  @@index([parentId, createdAt])
+  @@index([userId, createdAt])
+}
+
+model Reaction {
+  id         String   @id @default(cuid())
+  userId     String
+  commentId  String
+  kind       String   @default("like") // extensible later
+  createdAt  DateTime @default(now())
+
+  user       User     @relation(fields: [userId], references: [id])
+  comment    Comment  @relation(fields: [commentId], references: [id])
+
+  @@unique([userId, commentId, kind])
+  @@index([commentId])
+}
