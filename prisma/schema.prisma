generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Team {
  id         String @id @default(cuid())
  slug       String @unique // ðŸ”¹ Canonical key for teamMeta.ts
  name       String @unique // Stable internal name (e.g., "Left")
  nickname   String // Display name (e.g., "The Lions")
  users      User[]
  totalVotes Int    @default(0) // Total team votes (for leaderboards)
}

enum Role {
  USER
  ADMIN
}

model User {
  id                String             @id @default(cuid())
  name              String             @unique
  email             String             @unique
  emailVerified     DateTime?
  image             String?
  password          String?
  teamId            String?
  team              Team?              @relation(fields: [teamId], references: [id])
  rankId            Int? // optional at first
  rank              Rank?              @relation(fields: [rankId], references: [id])
  role              Role               @default(USER) // <-- New
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  onboardingAnswers OnboardingAnswer[] // <-- Relation
  badges            UserBadge[] //<-- Relation
  // ðŸ”¹ Streak & participation tracking
  streakCount       Int                @default(0) // current daily streak
  totalVotes        Int                @default(0) // lifetime votes
  lastVotedDate     DateTime? // date of last vote

  accounts  Account[]
  sessions  Session[]
  votes     Vote[]
  threads   Thread[] // Thread.createdBy
  comments  Comment[] // Comment.user
  reactions Reaction[] // Reaction.user
}

model Rank {
  id          Int    @id
  title       String
  minVotes    Int
  description String
  users       User[]
}

model OnboardingAnswer {
  id        String   @id @default(cuid())
  userId    String
  question  String
  answer    String
  points    Int
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id])

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Poll {
  id        String    @id @default(cuid())
  question  String
  startDate DateTime
  endDate   DateTime
  closedAt  DateTime? // When poll is closed & results are revealed
  options   Option[]

  threads Thread[] // Thread.poll

  @@index([startDate])
  @@index([endDate])
}

model Option {
  id     String @id @default(cuid())
  text   String
  pollId String
  poll   Poll   @relation(fields: [pollId], references: [id])
  votes  Vote[]

  @@index([pollId])
}

model Vote {
  id        String   @id @default(cuid())
  userId    String
  optionId  String
  timestamp DateTime @default(now())

  user   User   @relation(fields: [userId], references: [id])
  option Option @relation(fields: [optionId], references: [id])

  @@index([userId, timestamp])
  @@index([optionId, timestamp])
}

model Badge {
  id          Int         @id @default(autoincrement())
  name        String      @unique
  icon        String // Emoji or path to image
  description String
  unlockHint  String // How to earn it
  users       UserBadge[]
}

model UserBadge {
  id       Int      @id @default(autoincrement())
  user     User     @relation(fields: [userId], references: [id])
  userId   String
  badge    Badge    @relation(fields: [badgeId], references: [id])
  badgeId  Int
  earnedAt DateTime @default(now())

  @@unique([userId, badgeId])
  @@index([userId, earnedAt])
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Comments / Threads MVP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

enum ThreadType {
  POLL // per-poll discussion (link via pollId)
  TOPIC // user-created subject
  FEEDBACK // app feedback
}

model Thread {
  id          String     @id @default(cuid())
  type        ThreadType
  title       String
  pollId      String?
  createdById String
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  // denormalized for sorting
  commentCount Int @default(0)
  likeCount    Int @default(0)

  createdBy User      @relation(fields: [createdById], references: [id])
  poll      Poll?     @relation(fields: [pollId], references: [id])
  comments  Comment[]

  @@index([type, createdAt])
  @@index([pollId])
}

model Comment {
  id          String    @id @default(cuid())
  threadId    String
  parentId    String?
  userId      String
  content     String
  isAnonymous Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  // denormalized for sorting
  replyCount Int @default(0)
  likeCount  Int @default(0)

  thread    Thread     @relation(fields: [threadId], references: [id])
  parent    Comment?   @relation("CommentChildren", fields: [parentId], references: [id])
  children  Comment[]  @relation("CommentChildren")
  user      User       @relation(fields: [userId], references: [id])
  reactions Reaction[]

  @@index([threadId, createdAt])
  @@index([parentId, createdAt])
  @@index([userId, createdAt])
}

model Reaction {
  id        String   @id @default(cuid())
  userId    String
  commentId String
  kind      String   @default("like")
  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id])
  comment Comment @relation(fields: [commentId], references: [id])

  @@unique([userId, commentId, kind])
  @@index([commentId])
}
