generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Team {
  id         String @id @default(cuid())
  slug       String @unique // ðŸ”¹ Canonical key for teamMeta.ts
  name       String @unique // Stable internal name (e.g., "Left")
  nickname   String // Display name (e.g., "The Lions")
  users      User[]
  totalVotes Int    @default(0) // Total team votes (for leaderboards)
}

enum Role {
  USER
  ADMIN
}

model User {
  id                String             @id @default(cuid())
  name              String             @unique
  email             String             @unique
  emailVerified     DateTime?
  image             String?
  password          String?
  teamId            String?
  team              Team?              @relation(fields: [teamId], references: [id])
  rankId            Int? // optional at first
  rank              Rank?              @relation(fields: [rankId], references: [id])
  role              Role               @default(USER) // <-- New
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  onboardingAnswers OnboardingAnswer[] // <-- Relation
  badges            UserBadge[] //<-- Relation
  // ðŸ”¹ Streak & participation tracking
  streakCount       Int                @default(0) // current daily streak
  totalVotes        Int                @default(0) // lifetime votes
  lastVotedDate     DateTime? // date of last vote

  accounts Account[]
  sessions Session[]
  votes    Vote[]
}

model Rank {
  id          Int    @id
  title       String
  minVotes    Int
  description String
  users       User[]
}

model OnboardingAnswer {
  id        String   @id @default(cuid())
  userId    String
  question  String
  answer    String
  points    Int
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id])

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Poll {
  id        String    @id @default(cuid())
  question  String
  startDate DateTime
  endDate   DateTime
  closedAt  DateTime? // When poll is closed & results are revealed
  options   Option[]

  @@index([startDate])
  @@index([endDate])
}

model Option {
  id     String @id @default(cuid())
  text   String
  pollId String
  poll   Poll   @relation(fields: [pollId], references: [id])
  votes  Vote[]

  @@index([pollId])
}

model Vote {
  id        String   @id @default(cuid())
  userId    String
  optionId  String
  timestamp DateTime @default(now())

  user   User   @relation(fields: [userId], references: [id])
  option Option @relation(fields: [optionId], references: [id])

  @@index([userId, timestamp])
  @@index([optionId, timestamp])
}

model Badge {
  id          Int         @id @default(autoincrement())
  name        String      @unique
  icon        String // Emoji or path to image
  description String
  unlockHint  String // How to earn it
  users       UserBadge[]
}

model UserBadge {
  id       Int      @id @default(autoincrement())
  user     User     @relation(fields: [userId], references: [id])
  userId   String
  badge    Badge    @relation(fields: [badgeId], references: [id])
  badgeId  Int
  earnedAt DateTime @default(now())

  @@unique([userId, badgeId])
  @@index([userId, earnedAt])
}
